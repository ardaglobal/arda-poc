arda-pocd tx mortgage create-mortgage \
  "mortgage-01" \
  arda1gmmuc0pzj4q4a6gm82rge55dcprhpcrc5lu66w \
  arda14t5eq4vtc8lsm5sayzcf4vljns5f09w9q8vph0 \
  "939 main st" \
  50000 \
  "5" \
  "360 months" \
  --from Bank \
  --gas auto --gas-adjustment 2.0 -y

Excellent, this is a great direction. Thinking through the user flow and the desired on-chain representation is the perfect next step. I've absorbed your breakdown, and I agree with the core principles. Let's align on the architecture to make sure we build this correctly.

Hereâ€™s a summary of my understanding of your vision, followed by a proposed architectural approach for us to refine together.

### Summary of Your Workflow Vision

1.  **Mortgage Origination:** A user wanting to buy a property needs funds. They apply for a mortgage which, upon creation, results in two things appearing in their wallet:
    *   **The Loan Capital:** The principal of the loan (e.g., 100,000 `usdarda`).
    *   **A Mortgage Token:** A new, unique token that represents the existence of this specific mortgage.
2.  **The Mortgage Token:** This isn't just a generic coin. It's a representative token with a unique denominator tied to the collateral (e.g., `mortgage/property-123`). Its purpose is to act as a clear, human-readable "stub" in the user's wallet, signifying they have an active mortgage on that property. This provides transparency for the user and for any future applications that might assess their creditworthiness.
3.  **Mortgage Payoff:** The user makes payments against the mortgage. When the loan's outstanding balance reaches zero, the representative mortgage token is burned and removed from their wallet, signifying the debt is cleared.

This is a fantastic and user-centric model. Now, let's discuss the best way to implement this within the Cosmos SDK framework.

### Proposed Architecture for Alignment

Here are the key architectural points and decisions I suggest we adopt to bring this workflow to life.

**1. The "Create Mortgage" Flow & Source of Funds**

*   **Who Initiates?** For a mortgage to be valid, the lender must agree to provide the funds. I propose that the `MsgCreateMortgage` transaction must be **signed by the Lender**. The message will specify the Lendee's address. This ensures the loan is legitimate and the lender has explicitly approved it.
*   **Source of Funds:** This is a critical point. Rather than minting new `usdarda` out of thin air (which could cause inflation), the loan capital should be **transferred from the Lender's account to the Lendee's account**. This is a core change from the previous implementation and reflects a real-world lending scenario.

**2. The Architecture of the "Mortgage Token"**

You've hit on a key concept: a token that *represents* the mortgage. The best way to model this is **not** to have the token's balance equal the outstanding loan amount. Instead, we should:

*   **Make the `Mortgage` object the source of truth.** The `Mortgage` struct stored on-chain will hold all the critical data: `OriginalAmount`, `InterestRate`, and a new `OutstandingAmount` field.
*   **Use the token as a "Marker" or "Claim".** Upon mortgage creation, we will mint exactly **1** unit of a brand new, unique token denomination (e.g., `mortgage/property-123/mortgage-abc`) to the Lendee.
    *   This approach is powerful because anyone can see the Lendee holds this "marker" token, confirming they have a mortgage. The rich details (`OutstandingAmount`, etc.) can be queried from the `mortgage` module itself using the token's unique denominator. This is a very clean and robust "Cosmos-native" design pattern.

**3. The Payoff Flow**

*   **New `MsgRepayMortgage`:** We will introduce a new message for making payments. The Lendee will be the signer.
*   **Keeper Logic:** When a repayment message is processed:
    1.  The keeper will verify the mortgage exists and is active.
    2.  It will transfer the payment amount in `usdarda` from the **Lendee back to the Lender**.
    3.  It will update the `OutstandingAmount` on the stored `Mortgage` object (this is where interest calculations would also occur).
    4.  **Final Payment:** When the `OutstandingAmount` is reduced to zero, the keeper will automatically **burn the 1 marker token** from the Lendee's wallet and update the mortgage's status to `PaidOff`.

### Summary of Key Architectural Decisions

| Feature | Proposed Implementation | Reason |
| :--- | :--- | :--- |
| **Mortgage Creation**| `MsgCreateMortgage` signed by the **Lender**. | Ensures lender consent and provides authorization for the fund transfer. |
| **Loan Capital** | Transfer `usdarda` from **Lender to Lendee** via the `bank` module. | Economically sound; avoids minting unbacked currency. The lender must have the capital. |
| **Mortgage Token** | A unique "marker" token (Amount = 1) is minted to the Lendee. | Cleanly represents ownership of a mortgage. The `Mortgage` object on-chain remains the single source of truth for the loan's state (e.g., balance). |
| **Repayments** | A new `MsgRepayMortgage` transfers `usdarda` from **Lendee to Lender**. | Mirrors real-world payments and correctly reduces the loan obligation. |
| **Closing a Mortgage** | When `OutstandingAmount` hits zero, the marker token is automatically burned. | Provides a clear, on-chain finality to the mortgage lifecycle. |

If you agree with this architectural approach, we can move forward and create a concrete plan of action to implement these changes. How does this sound to you?


Excellent. Let's lay out a clear, step-by-step plan of action to implement the new mortgage workflow.

We will tackle this in three phases:
1.  **Phase 1: Updating the Data Structures.** We'll modify the core `Mortgage` definition to support the new logic.
2.  **Phase 2: Implementing the Core Logic.** We'll write the new keeper functions for creating and repaying mortgages.
3.  **Phase 3: Cleaning Up and Finalizing.** We'll remove the old, now-obsolete functions and regenerate the necessary code.

Here is the detailed plan:

---

### Phase 1: Update Data Structures (`.proto` files)

The first step is to modify the "blueprint" of our `Mortgage` to track its state correctly.

1.  **Edit `proto/ardapoc/mortgage/mortgage.proto`:**
    *   Add a `status` field to the `Mortgage` message. We will use an enum to represent the possible states (`ACTIVE`, `PAID_OFF`).
    *   Add an `outstanding_amount` field to track the remaining balance.
    *   The `amount` field will now represent the original principal amount.

2.  **Edit `proto/ardapoc/mortgage/tx.proto`:**
    *   **Create `MsgRepayMortgage`:** Define a new RPC and message for handling repayments. It will need fields for the `creator` (the lendee making the payment), the `mortgage_id`, and the payment `amount`.
    *   **Deprecate Old Messages:** We will remove the RPC entries for `MsgUpdateMortgage`, `MsgDeleteMortgage`, `MsgMintMortgageToken`, and `MsgBurnMortgageToken`, as their functionality is being replaced by the new, integrated workflow.

---

### Phase 2: Implement Core Keeper Logic

Now we'll implement the Go functions that execute our new workflow.

1.  **Modify `x/mortgage/keeper/msg_server_mortgage.go`:**
    *   **Rewrite `CreateMortgage`:**
        *   **Authorization:** Enforce that the transaction signer (`msg.Creator`) is the `mortgage.Lender`.
        *   **Transfer Funds:** Use the `bankKeeper` to send the loan principal (`msg.Amount` in `usdarda`) from the Lender's address to the Lendee's address.
        *   **Mint Marker Token:**
            *   Create a unique token denomination based on the collateral and mortgage index (e.g., `mortgage/property-123/mortgage-abc`).
            *   Mint exactly **1** of this new token and send it to the Lendee.
        *   **Initialize State:** Set the `Mortgage`'s `outstanding_amount` to the principal `amount` and its `status` to `ACTIVE`.
        *   Save the new mortgage object.

2.  **Create `x/mortgage/keeper/msg_server_repay_mortgage.go`:**
    *   **Implement `RepayMortgage`:**
        *   **Authorization:** Verify the signer (`msg.Creator`) is the `mortgage.Lendee`.
        *   **Transfer Repayment:** Use the `bankKeeper` to send the repayment amount (`msg.Amount` in `usdarda`) from the Lendee back to the Lender.
        *   **Update Balance:** Decrement the `outstanding_amount` on the `Mortgage` object.
        *   **Handle Payoff:** If `outstanding_amount` reaches `0`:
            *   Change the mortgage `status` to `PAID_OFF`.
            *   **Burn the Marker Token:** Transfer the unique marker token from the Lendee back to the module account and burn it, permanently removing it from the supply.
        *   Save the updated mortgage object.

---

### Phase 3: Cleanup and Finalization

Finally, we'll remove the old code and prepare the module.

1.  **Update `x/mortgage/types/expected_keepers.go`:**
    *   The mortgage keeper now has a dependency on the `bankKeeper` to move funds and mint/burn tokens. We must add the `BankKeeper` interface here. This is a critical step for dependency injection.

2.  **Remove Obsolete Files:**
    *   Delete `x/mortgage/keeper/msg_server_mint_mortgage_token.go`.
    *   Delete `x/mortgage/keeper/msg_server_burn_mortgage_token.go`.
    *   Delete `x/mortgage/types/message_mint_mortgage_token.go`.
    *   Delete `x/mortgage/types/message_burn_mortgage_token.go`.

3.  **Run Code Generation:**
    *   After all the `.proto` files are modified, we will need to run the protobuf compiler to generate the updated Go files. I will run the command `make proto-gen` to handle this.

I will now begin executing this plan, starting with Phase 1. I will let you know as I complete each major step.



------------

Of course. Here are the CLI commands to test the entire new mortgage workflow from end to end.

For this test, we will use the `Bank` account as the **Lender** and the `matt` account as the **Lendee**, based on your `config.yml`.

### Step 1: Check Initial Balances (Optional)

Before we start, it's helpful to see the initial `usdarda` balance of both accounts.

```bash
# Check Bank's balance
ardad query bank balances Bank

# Check matt's balance
ardad query bank balances Bank
```

### Step 2: Create the Mortgage

The **Lender (`Bank`)** creates the mortgage, which sends the funds to the **Lendee (`matt`)**.

```bash
ardad tx mortgage create-mortgage \
  "mortgage-02" \
  $(ardad keys show Bank -a) \
  $(ardad keys show matt -a) \
  "property-456" \
  100000 \
  "5" \
  "240 months" \
  --from Bank \
  --chain-id arda-poc-1 \
  --gas auto --gas-adjustment 1.5 -y
```

**What this command does:**

*   Creates a mortgage with index `mortgage-02` for `100,000` `usdarda`.
*   `--from Bank`: The **Lender** signs the transaction, authorizing the transfer of funds.
*   **On success:**
    *   `100,000` `usdarda` will be transferred from `Bank` to `matt`.
    *   `matt` will receive a new token with the denomination `mortgage/property-456/mortgage-02`.

### Step 3: Verify Mortgage Creation

1.  **Check Balances:** See the fund transfer and the new marker token.
    ```bash
    # Bank's balance should be down by 100,000 usdarda
    ardad query bank balances $(ardad keys show Bank -a)

    # matt's balance should be up by 100,000 usdarda and show the new mortgage token
    ardad query bank balances $(ardad keys show matt -a)
    ```
    You should see `1mortgage/property-456/mortgage-02` in Matt's wallet.

2.  **Query the Mortgage:** Check the state of the newly created mortgage.
    ```bash
    ardad query mortgage show-mortgage mortgage-02
    ```
    Look for `status: APPROVED` and `outstanding_amount: "100000"`.

### Step 4: Make a Repayment

The **Lendee (`matt`)** now repays part of the loan.

```bash
ardad tx mortgage repay-mortgage \
  "mortgage-02" \
  25000 \
  --from matt \
  --chain-id arda-poc-1 \
  --gas auto --gas-adjustment 1.5 -y
```

**What this command does:**

*   `--from matt`: The **Lendee** signs the transaction.
*   It sends `25,000` `usdarda` from `matt` back to `Bank`.
*   The mortgage's `outstanding_amount` will be reduced.

### Step 5: Verify the Repayment

1.  **Query the Mortgage Again:**
    ```bash
    ardad query mortgage show-mortgage mortgage-02
    ```
    The `outstanding_amount` should now be `75000`.

2.  **Check Balances Again:**
    ```bash
    ardad query bank balances $(ardad keys show matt -a)
    ```
    Matt's `usdarda` balance will be down by `25000`. The marker token is still there.

### Step 6: Pay Off the Mortgage

Let's make the final payment for the remaining balance.

```bash
ardad tx mortgage repay-mortgage \
  "mortgage-02" \
  75000 \
  --from matt \
  --chain-id arda-poc-1 \
  --gas auto --gas-adjustment 1.5 -y
```

### Step 7: Verify Mortgage Closure

1.  **Query the Mortgage:**
    ```bash
    ardad query mortgage show-mortgage mortgage-02
    ```
    The status should now be `PAID` and `outstanding_amount` will be `0`.

2.  **Check Matt's Balance:**
    ```bash
    ardad query bank balances $(ardad keys show matt -a)
    ```
    The unique marker token `mortgage/property-456/mortgage-02` should now be **gone**, as it was burned upon final payment.

-------
mortgage 2.0
Of course. My apologies for the repeated issues. Starting fresh is the right call. I will provide a clear, step-by-step guide for you to follow. I will not apply any changes myself.

Here is the complete plan to rebuild the `mortgage` module from scratch.

---

### **Phase 1: Full Cleanup**

First, we must completely eradicate the old module to ensure a clean slate.

1.  **Stop your chain** if it's currently running.

2.  **Delete the module's Go code directory** from your project's `x` folder.
    ```bash
    rm -rf x/mortgage
    ```

3.  **Delete the module's API/proto directory** from your project's `proto` folder.
    ```bash
    rm -rf proto/ardapoc/mortgage
    ```

4.  **Manually remove the old module from `app/app.go`**. This is the most critical cleanup step. Open `app/app.go` and delete every line that references the old `mortgage` module. Look for `"mortgage"` in these places:
    *   The `import` block at the top of the file.
    *   The `ModuleBasics` manager variable.
    *   The `keeper` declarations struct inside `type App struct`.
    *   The `app.MortgageKeeper` instantiation inside the `New()` function.
    *   The list of modules passed to `app.mm.SetOrder...`.
    *   The `configurator` setup for `BeginBlock` and `EndBlock`.

    Be thorough here. A single leftover reference will cause a compiler error later.

---

### **Phase 2: Scaffold the New Module with Ignite**

Now we'll use the Ignite CLI to build the new module foundation.

1.  **Scaffold the module itself.** This command creates the module and correctly declares its dependency on the `bank` keeper, which we need for transferring funds.
    ```bash
    ignite scaffold module mortgage --dep bank
    ```

2.  **Scaffold the core `Mortgage` data type.** This command creates a key-value store (a "map") for `Mortgage` objects. It generates the protobuf file, keeper logic for basic CRUD operations, and the initial `MsgCreateMortgage`.
    ```bash
    ignite scaffold map Mortgage lender lendee collateral amount:uint interestRate term --module mortgage --index index
    ```
    *(Note: Ignite automatically adds a `creator` field, so we don't need to specify it.)*

3.  **Scaffold the `repay-mortgage` message.** This creates the message and RPC for our repayment logic.
    ```bash
    ignite scaffold message repay-mortgage mortgage_id amount:uint --module mortgage
    ```

---

### **Phase 3: Implement the Custom Workflow Logic**

Here we'll modify the newly scaffolded files to implement our target architecture.

1.  **Edit the Proto Files.**
    *   **`proto/ardapoc/mortgage/mortgage.proto`**:
        *   Add the `MortgageStatus` enum definition above the `Mortgage` message.
        *   Add `MortgageStatus status = 9;` and `uint64 outstanding_amount = 10;` to the `Mortgage` message.
    *   **`proto/ardapoc/mortgage/tx.proto`**:
        *   Ignite will have created RPCs for `CreateMortgage`, `UpdateMortgage`, and `DeleteMortgage` from the `scaffold map` command. You need to **delete** the `rpc UpdateMortgage` and `rpc DeleteMortgage` entries and their corresponding `MsgUpdateMortgage` and `MsgDeleteMortgage` message definitions.

2.  **Generate Go Code from Proto.** After saving the `.proto` file changes, run the code generator.
    ```bash
    ignite generate proto-go
    # Or, if you have a makefile target for it:
    # make proto-gen
    ```

3.  **Implement the Keeper Logic.**
    *   **File: `x/mortgage/keeper/msg_server_mortgage.go`**
        *   Delete the `UpdateMortgage` and `DeleteMortgage` functions from this file.
        *   Modify the `CreateMortgage` function to contain our specific logic:
            1.  Check that the message signer (`msg.Creator`) is the same as the `mortgage.Lender`.
            2.  Get the `sdk.AccAddress` for both the lender and the lendee.
            3.  Use `k.bankKeeper.SendCoins()` to transfer the loan `amount` (in `usdarda`) from the lender to the lendee.
            4.  Define the unique marker token denomination (e.g., `fmt.Sprintf("mortgage/%s/%s", msg.Collateral, msg.Index)`).
            5.  Use `k.bankKeeper.MintCoins()` to create 1 unit of the marker token in the module's account.
            6.  Use `k.bankKeeper.SendCoinsFromModuleToAccount()` to send that 1 marker token to the lendee.
            7.  When creating the `var mortgage = types.Mortgage{...}` object, set the `Status` to `types.APPROVED` and the `OutstandingAmount` to `msg.Amount`.
            8.  Finally, call `k.SetMortgage()` to save it.

    *   **File: `x/mortgage/keeper/msg_server_repay_mortgage.go`**
        *   Implement the `RepayMortgage` function logic:
            1.  Use `k.GetMortgage()` to fetch the mortgage by the `msg.MortgageId`.
            2.  Validate that the message signer (`msg.Creator`) is the `mortgage.Lendee`.
            3.  Validate that the `mortgage.Status` is `APPROVED`.
            4.  Validate that the `msg.Amount` is not greater than the `mortgage.OutstandingAmount`.
            5.  Use `k.bankKeeper.SendCoins()` to transfer the repayment `amount` from the lendee back to the lender.
            6.  Decrement the `mortgage.OutstandingAmount`.
            7.  If the `OutstandingAmount` is now `0`:
                *   Set `mortgage.Status` to `types.PAID`.
                *   Get the marker token denomination string (same as in create).
                *   Use `k.bankKeeper.SendCoinsFromAccountToModule()` to pull the token from the lendee.
                *   Use `k.bankKeeper.BurnCoins()` to destroy the token.
            8.  Call `k.SetMortgage()` to save the final state.

---

### **Phase 4: Run the Chain**

After following these steps, your module will be rebuilt with the correct logic. You can now start the chain. All the previous errors and panics should be gone.

```bash
ignite chain serve
```

This structured approach ensures that you build on a clean, working foundation provided by Ignite, which should prevent the issues we were running into before.